# Counting Sort Part1

ソート対象である配列内に出現する整数が何回出現したかを配列に格納してReturnする.
ソート対象である配列内の整数が `[1, 1, 3, 2, 1]` だった場合、出現回数を記録する配列のサイズは `0...3` となる。
```go
result := make([]int32, 4)
// [0 0 0 0]
```

上の例では データである 1 が3回出現しているため、`result[1]` に出現回数をインクリメントしていく。これを順に行うと以下なる
```go
i	arr[i]	result[arr[i]]++
0	1	    [0, 1, 0, 0]
1	1	    [0, 2, 0, 0]
2	3	    [0, 2, 0, 1]
3	2	    [0, 2, 1, 1]
4	1	    [0, 3, 1, 1]
```


カウンティングソートは、比較を必要としない。その代わりに、ソートする配列の値の全範囲をカバーするインデックスを持つ整数配列を作成する。元の配列に値が出現するたびに、そのインデックスのカウンタをインクリメントする。最後に、カウンティング配列を通して、ゼロでない値のインデックスの値をその回数だけ表示します。

Example:  
```go
arr = [1, 1, 3, 2, 1]
```
すべての値は範囲 `[0...3]` にあるので、ゼロの配列 `result = [0,0,0,0]` を作成する。各反復の結果が続く：

```go
i	arr[i]	result
0	1	    [0, 1, 0, 0]
1	1	    [0, 2, 0, 0]
2	3	    [0, 2, 0, 1]
3	2	    [0, 2, 1, 1]
4	1	    [0, 3, 1, 1]
```
度数配列は[0, 3, 1, 1]である。sorted = [1, 1, 2, 3]。これらの値は、ソート配列の作成にも使用できます。

 この練習では、常に100個の要素を持つ度数配列を返します。上の例では、最初の4つの要素だけを示しており、残りはゼロである。


## Counting Sortとは

ソート対象のデータをキーにして、キーの出現回数とその累積度数分布を計算して、利用することでソートするアルゴリズム

1. 例としてソート対象のデータを A = {5, 3, 3, 1, 4} とする。  
2. 作業用の配列 B を用意する
3. 数え上げるための配列 C を用意する
4. C を利用して、ソート対象 A データの出現頻度を数える
5. キーの累積度数分布を求める (Cが保持している)
6. Cの累積度数分布に従って A から B にデータをコピーする

4, 5の手順を表にすると以下

| データの範囲(キー) | キーの出現回数(X) | 出現回数の累計(Y) |
| :----------------: | :---------------: | :---------------: |
|         0          |         0         |         0         |
|         1          |         1         |         1         |
|         2          |         0         |         0         |
|         3          |         2         |         3         |
|         4          |         1         |         4         |
|         5          |         1         |         5         |


![](https://www.codereading.com/algo_and_ds/algo/images/counting-sort.png)